<!DOCTYPE html>
<html>

<head>
    <title>COVID-19 USA</title>
    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Map of US showing COVID cases by state and county" />
    <meta name="keywords" content="COVID-19, covid, coronavirus, tracker, map, corona, us, usa" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
        integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
        crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"
        integrity="sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew=="
        crossorigin=""></script>
    <script src="https://unpkg.com/topojson-client@3"></script>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="map">
        <div class="leaflet-top leaflet-right">
            <div class="info leaflet-control">
                <span id="toggle" class="close" onclick="toggleHelp()">â†’</span>
                <h4 class="help">What is this website?</h4>
                <p class="help">This website shows the cumulative number of COVID-19 cases in the US. Zoom in to see
                    counties.</p>
                <h4 class="help">Where is the data gathered from?</h4>
                <p class="help">Data is fetched from the <a href="https://github.com/nytimes/covid-19-data">New York
                        Times Github</a>
                    and updates twice per day.</p>
            </div>
        </div>
        <script type="text/javascript" src="index.js"></script>
        <script type="text/javascript">
            let display = "state";
            var map = L.map("map").setView([39.8283, -98.5795], 5);

            L.tileLayer(
                "https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png", {
                    maxZoom: 8,
                    minZoom: 4,
                    attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
                        '&copy; <a href="https://www.stadiamaps.com/">Stadia Maps</a>, ' +
                        '&copy; <a href="https://openmaptiles.org/"> OpenMapTiles </a>' + 
                        '&copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
                }
            ).addTo(map);

            map.createPane('labels');
            map.getPane('labels').style.zIndex = 500;

            var positronLabels = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', {
                maxZoom: 8,
                minZoom: 4,
                pane: 'labels'
            }).addTo(map);

            function getColor(d) {
                if (display == 'county') {
                    return d > 1000 ?
                        "#800026" :
                        d > 500 ?
                        "#BD0026" :
                        d > 200 ?
                        "#E31A1C" :
                        d > 100 ?
                        "#FC4E2A" :
                        d > 50 ?
                        "#FD8D3C" :
                        d > 20 ? "#FEB24C" : d > 10 ? "#FED976" : "#FFEDA0";
                } else {
                    return d > 200000 ?
                        "#800026" :
                        d > 100000 ?
                        "#BD0026" :
                        d > 40000 ?
                        "#E31A1C" :
                        d > 20000 ?
                        "#FC4E2A" :
                        d > 10000 ?
                        "#FD8D3C" :
                        d > 4000 ? "#FEB24C" : d > 2000 ? "#FED976" : "#FFEDA0";
                }
            }

            function style(feature) {
                return {
                    weight: 1,
                    color: "#212F3D",
                    fillOpacity: 0.4,
                    fillColor: getColor(feature.properties.cases)
                };
            }

            function highlightFeature(e) {
                const layer = e.target;

                const mid = midpoint(layer._bounds._northEast.lat, layer._bounds._northEast.lng, layer._bounds
                    ._southWest.lat, layer._bounds._southWest.lng)

                let location = L.latLng(layer._bounds._northEast.lat, mid[1]);

                const tooltip = L.tooltip().setContent(
                    `<b>${layer.feature.properties.name} ${display == "county" ? "County" : ""}</b><br>${layer.feature.properties.cases} cases`
                );
                layer.bindTooltip(tooltip, {
                    className: 'tooltip',
                    direction: 'top',
                }).openTooltip(location);

                layer.setStyle({
                    weight: 1,
                    color: "white",
                });

                if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                    layer.bringToFront();
                }

            }

            function midpoint(lat1, lng1, lat2, lng2) {
                lat1 = deg2rad(lat1);
                lng1 = deg2rad(lng1);
                lat2 = deg2rad(lat2);
                lng2 = deg2rad(lng2);

                dlng = lng2 - lng1;
                Bx = Math.cos(lat2) * Math.cos(dlng);
                By = Math.cos(lat2) * Math.sin(dlng);
                lat3 = Math.atan2(Math.sin(lat1) + Math.sin(lat2),
                    Math.sqrt((Math.cos(lat1) + Bx) * (Math.cos(lat1) + Bx) + By * By));
                lng3 = lng1 + Math.atan2(By, (Math.cos(lat1) + Bx));

                lng3 = (lng3 * 180) / Math.PI;
                if (lng3 > 180) {
                    lng3 -= 360;
                }

                return [(lat3 * 180) / Math.PI, lng3];
            }

            function deg2rad(degrees) {
                return degrees * Math.PI / 180;
            };

            var geojson;

            L.TopoJSON = L.GeoJSON.extend({
                addData: function (data) {
                    var geojson, key;
                    if (data.type === "Topology") {
                        for (key in data.objects) {
                            if (data.objects.hasOwnProperty(key)) {
                                geojson = topojson.feature(data, data.objects[key]);
                                L.GeoJSON.prototype.addData.call(this, geojson);
                            }
                        }
                        return this;
                    }
                    L.GeoJSON.prototype.addData.call(this, data);
                    return this;
                }
            });
            L.topoJson = function (data, options) {
                return new L.TopoJSON(data, options);
            };

            var geojson = L.topoJson(null, {
                style: style,
                onEachFeature: onEachFeature
            }).addTo(map)

            function resetHighlight(e) {
                e.target.unbindTooltip();
                geojson.resetStyle(e.target);
            }

            function zoomToFeature(e) {
                map.fitBounds(e.target.getBounds());
            }

            function onEachFeature(feature, layer) {
                layer.on({
                    mouseover: highlightFeature,
                    mouseout: resetHighlight,
                    click: zoomToFeature
                });
            }

            async function getGeoData(url) {
                let response = await fetch(url);
                let data = await response.json();
                return data;
            }

            var legend = L.control({
                position: "bottomright"
            });

            function setLegend() {
                legend.onAdd = function (map) {
                    var div = L.DomUtil.create("div", "info legend"),
                        labels = [],
                        from,
                        to;

                    if (display == 'county') {
                        grades = [0, 10, 20, 50, 100, 200, 500, 1000]
                    } else {
                        grades = [0, 2000, 4000, 10000, 20000, 40000, 100000, 200000]
                    }

                    for (var i = 0; i < grades.length; i++) {
                        from = grades[i];
                        to = grades[i + 1];

                        labels.push(
                            '<i style="background:' +
                            getColor(from + 1) +
                            '"></i> ' +
                            from +
                            (to ? "&ndash;" + to : "+")
                        );
                    }

                    div.innerHTML = labels.join("<br>");
                    return div;
                };

                legend.addTo(map);
            }

            update();

            map.on('zoomend', function (zoom) {
                if (display == "state" && map.getZoom() > 5) {
                    display = 'county'
                    update()
                } else if (display == "county" && map.getZoom() <= 5) {
                    display = 'state'
                    update()
                }
            });

            function update() {
                setLegend();
                geojson.clearLayers();
                if (display == 'state') {
                    getGeoData('statestopo.json').then(data => geojson.addData(data));
                } else {
                    getGeoData('countiestopo.json').then(data => geojson.addData(data));
                }
            }
        </script>
    </div>
</body>

</html>